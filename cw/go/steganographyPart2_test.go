// https://www.codewars.com/kata/624fc787983b3500648faf11

package kata

import (
	"reflect"
	"testing"
)

func Extract(pixels [][]uint8) string {

	var set_bit = func(store byte, idx byte, bit_val byte) byte {
		if bit_val == 0 {
			return store &^ (1 << idx)
		} else {
			return store | (1 << idx)
		}
	}
	var get_lsb = func(store byte) byte {
		return store & 1
	}

	var res = []byte{}
	for i := 0; i < len(pixels); i += 3 {
		var tmp = []byte{}
		tmp = append(tmp, pixels[i]...)
		tmp = append(tmp, pixels[i+1]...)
		tmp = append(tmp, pixels[i+2][0:2]...)

		var ch byte = 0
		for j := 0; j < 8; j++ {
			var bit_val = get_lsb(tmp[j])
			ch = set_bit(ch, byte(7-j), bit_val)
		}

		res = append(res, ch)

	}
	return string(res[:])
}

// go test -run TestExtractCase1
func TestExtractCase1(t *testing.T) {
	case1_input := [][]uint8{
		{200, 213, 128}, {8, 71, 54}, {154, 124, 135},
		{138, 175, 117}, {64, 98, 137}, {142, 191, 5},
		{120, 113, 209}, {20, 167, 193}, {38, 146, 171},
		{88, 235, 147}, {180, 221, 49}, {24, 186, 226},
		{244, 215, 195}, {114, 19, 67}, {101, 161, 57},
	}

	case1_output := "Hello"
	case1_res := Extract(case1_input)
	if !reflect.DeepEqual(case1_res, case1_output) {
		t.Logf("\nv=%v\ne=%v", case1_output, case1_res)
		t.Fail()
	}
}

func TestExtractCase2(t *testing.T) {
	case1_input := [][]uint8{
		{144, 237, 136}, {171, 124, 19}, {171, 207, 178},
		{118, 87, 161}, {34, 138, 229}, {202, 85, 175},
		{160, 79, 45}, {108, 79, 3}, {120, 140, 129},
		{16, 253, 191}, {190, 117, 175}, {86, 126, 13},
		{222, 12, 183}, {194, 52, 14}, {92, 102, 223},
		{180, 113, 69}, {85, 80, 235}, {66, 156, 110},
		{108, 1, 179}, {70, 145, 138}, {250, 172, 57},
		{60, 19, 127}, {8, 14, 144}, {232, 69, 55},
		{56, 245, 45}, {189, 130, 191}, {88, 124, 74},
		{248, 92, 27}, {126, 52, 175}, {79, 247, 236},
		{2, 157, 247}, {247, 198, 154}, {91, 143, 103},
		{180, 34, 113}, {118, 226, 212}, {88, 58, 85},
		{70, 221, 105}, {14, 70, 32}, {28, 233, 1},
		{36, 25, 67}, {174, 219, 219}, {6, 58, 208},
		{52, 65, 219}, {159, 228, 8}, {213, 90, 228},
		{16, 87, 141}, {134, 147, 44}, {210, 127, 42},
		{194, 243, 187}, {228, 134, 161}, {243, 7, 148},
		{80, 3, 205}, {204, 247, 92}, {144, 226, 128},
		{214, 173, 255}, {133, 142, 161}, {200, 118, 223},
		{92, 106, 159}, {202, 183, 133}, {2, 224, 196},
		{34, 184, 187}, {234, 156, 242}, {34, 40, 161},
		{152, 101, 55}, {60, 239, 117}, {14, 62, 100},
		{130, 177, 43}, {56, 200, 235}, {158, 49, 226},
		{240, 207, 67}, {241, 16, 147}, {160, 46, 100},
		{224, 253, 51}, {139, 182, 132}, {123, 185, 130},
		{94, 68, 147}, {84, 136, 142}, {202, 56, 209},
		{164, 15, 181}, {48, 54, 71}, {183, 89, 223},
		{82, 183, 223}, {240, 121, 16}, {162, 63, 29},
		{52, 75, 199}, {127, 26, 145}, {7, 184, 243},
		{62, 207, 37}, {122, 64, 123}, {164, 225, 240},
		{42, 22, 161}, {14, 30, 184}, {54, 134, 215},
		{106, 215, 117}, {223, 4, 115}, {56, 204, 209},
		{56, 253, 81}, {12, 23, 150}, {254, 92, 192},
		{0, 195, 89}, {66, 31, 234}, {160, 39, 214},
		{158, 87, 27}, {75, 212, 74}, {215, 207, 149},
		{36, 240, 137}, {164, 50, 168}, {34, 184, 185},
		{106, 199, 191}, {6, 110, 78}, {58, 13, 123},
		{108, 143, 193}, {54, 217, 185}, {47, 112, 180},
		{194, 71, 129}, {222, 65, 239}, {39, 45, 30},
		{60, 199, 93}, {199, 18, 205}, {98, 182, 174},
		{180, 153, 3}, {14, 169, 58}, {212, 18, 117},
		{164, 13, 49}, {184, 120, 205}, {30, 43, 254},
		{50, 123, 97}, {77, 188, 174}, {175, 66, 191},
		{184, 144, 157}, {70, 48, 236}, {246, 248, 61},
		{230, 101, 211}, {205, 118, 33}, {216, 250, 80},
		{226, 93, 255}, {205, 218, 148}, {131, 200, 142},
		{156, 49, 153}, {135, 15, 170}, {234, 183, 141}}

	case1_output := "Well that's alright, lets give this another try"
	case1_res := Extract(case1_input)
	if !reflect.DeepEqual(case1_res, case1_output) {
		t.Logf("\nv=%v\ne=%v", case1_output, case1_res)
		t.Fail()
	}
}
